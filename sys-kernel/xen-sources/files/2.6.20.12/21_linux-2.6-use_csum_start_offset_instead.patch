From: Herbert Xu <herbert.xu@redhat.com>
Subject: [2/4] [NET]: Use csum_start offset instead of skb_transport_header

Hi:

Note this is based on the upstream net-2.6.22 tree so merging it
into anything before that will require undoing the transport header
changes.  Let me know if there are problems merging it.

[NET]: Use csum_start offset instead of skb_transport_header

The skb transport pointer is currently used to specify the start
of the checksum region for transmit checksum offload.  Unfortunately,
the same pointer is also used during receive side processing.

This creates a problem when we want to retransmit a received
packet with partial checksums since the skb transport pointer
would be overwritten.

This patch solves this problem by creating a new 16-bit csum_start
offset value to replace the skb transport header for the purpose
of checksums.  This offset is calculated from skb->head so that
it does not have to change when skb->data changes.

No extra space is required since csum_offset itself fits within
a 16-bit word so we can use the other 16 bits for csum_start.

For backwards compatibility, just before we push a packet with
partial checksums off into the device driver, we set the skb
transport header to what it would have been under the old scheme.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu 许志壬 <herbert@gondor.apana.org.au>
Home Page: http://gondor.apana.org.au/herbert/
PGP Key: http://gondor.apana.org.au/herbert/pubkey.txt
--
diff -ur linux-2.6.20.i386.orig/include/linux/skbuff.h linux-2.6.20.i386/include/linux/skbuff.h
--- linux-2.6.20.i386.orig/include/linux/skbuff.h	2007-04-24 13:31:01.000000000 +1000
+++ linux-2.6.20.i386/include/linux/skbuff.h	2007-04-24 13:42:01.000000000 +1000
@@ -198,7 +198,9 @@
  *	@len: Length of actual data
  *	@data_len: Data length
  *	@mac_len: Length of link layer header
- *	@csum: Checksum
+ *	@csum: Checksum (must include start/offset pair)
+ *	@csum_start: Offset from skb->head where checksumming should start
+ *	@csum_offset: Offset from csum_start where checksum should be stored
  *	@local_df: allow local fragmentation
  *	@cloned: Head may be cloned (check refcnt to be sure)
  *	@nohdr: Payload reference only, must not modify header
@@ -276,7 +278,10 @@
 				mac_len;
 	union {
 		__wsum		csum;
-		__u32		csum_offset;
+		struct {
+			__u16	csum_start;
+			__u16	csum_offset;
+		};
 	};
 	__u32			priority;
 	__u8			local_df:1,
diff -ur linux-2.6.20.i386.orig/net/core/dev.c linux-2.6.20.i386/net/core/dev.c
--- linux-2.6.20.i386.orig/net/core/dev.c	2007-04-24 13:18:41.000000000 +1000
+++ linux-2.6.20.i386/net/core/dev.c	2007-04-24 15:14:04.000000000 +1000
@@ -1176,7 +1176,7 @@
 int skb_checksum_help(struct sk_buff *skb)
 {
 	__wsum csum;
-	int ret = 0, offset = skb->h.raw - skb->data;
+	int ret = 0, offset;
 
 	if (skb->ip_summed == CHECKSUM_COMPLETE)
 		goto out_set_summed;
@@ -1192,14 +1192,16 @@
 			goto out;
 	}
 
+	offset = skb->csum_start - skb_headroom(skb);
 	BUG_ON(offset > (int)skb->len);
 	csum = skb_checksum(skb, offset, skb->len-offset, 0);
 
-	offset = skb->tail - skb->h.raw;
+	offset = skb_headlen(skb) - offset;
 	BUG_ON(offset <= 0);
 	BUG_ON(skb->csum_offset + 2 > offset);
 
-	*(__sum16*)(skb->h.raw + skb->csum_offset) = csum_fold(csum);
+	*(__sum16 *)(skb->head + skb->csum_start + skb->csum_offset) =
+		csum_fold(csum);
 
 out_set_summed:
 	skb->ip_summed = CHECKSUM_NONE;
@@ -1494,12 +1496,15 @@
 	/* If packet is not checksummed and device does not support
 	 * checksumming for this protocol, complete checksumming here.
 	 */
-	if (skb->ip_summed == CHECKSUM_PARTIAL &&
-	    (!(dev->features & NETIF_F_GEN_CSUM) &&
-	     (!(dev->features & NETIF_F_IP_CSUM) ||
-	      skb->protocol != htons(ETH_P_IP))))
-	      	if (skb_checksum_help(skb))
-	      		goto out_kfree_skb;
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		skb->h.raw = skb->head + skb->csum_start;
+
+		if (!(dev->features & NETIF_F_GEN_CSUM) &&
+		    (!(dev->features & NETIF_F_IP_CSUM) ||
+		     skb->protocol != htons(ETH_P_IP)))
+		      	if (skb_checksum_help(skb))
+		      		goto out_kfree_skb;
+	}
 
 gso:
 	spin_lock_prefetch(&dev->queue_lock);
diff -ur linux-2.6.20.i386.orig/net/core/skbuff.c linux-2.6.20.i386/net/core/skbuff.c
--- linux-2.6.20.i386.orig/net/core/skbuff.c	2007-04-24 13:18:41.000000000 +1000
+++ linux-2.6.20.i386/net/core/skbuff.c	2007-04-24 15:08:07.000000000 +1000
@@ -1422,7 +1422,7 @@
 	long csstart;
 
 	if (skb->ip_summed == CHECKSUM_PARTIAL)
-		csstart = skb->h.raw - skb->data;
+		csstart = skb->csum_start - skb_headroom(skb);
 	else
 		csstart = skb_headlen(skb);
 
diff -ur linux-2.6.20.i386.orig/net/ipv4/tcp_ipv4.c linux-2.6.20.i386/net/ipv4/tcp_ipv4.c
--- linux-2.6.20.i386.orig/net/ipv4/tcp_ipv4.c	2007-03-30 13:39:10.000000000 +1000
+++ linux-2.6.20.i386/net/ipv4/tcp_ipv4.c	2007-04-24 15:09:28.000000000 +1000
@@ -504,6 +504,7 @@
 	if (skb->ip_summed == CHECKSUM_PARTIAL) {
 		th->check = tcp_v4_check(th, len,
 					  inet->saddr, inet->daddr, 0);
+		skb->csum_start = skb->h.raw - skb->head;
 		skb->csum_offset = offsetof(struct tcphdr, check);
 	} else {
 		th->check = tcp_v4_check(th, len, inet->saddr, inet->daddr,
@@ -526,6 +527,7 @@
 
 	th->check = 0;
 	th->check = tcp_v4_check(th, skb->len, iph->saddr, iph->daddr, 0);
+	skb->csum_start = skb->h.raw - skb->head;
 	skb->csum_offset = offsetof(struct tcphdr, check);
 	skb->ip_summed = CHECKSUM_PARTIAL;
 	return 0;
diff -ur linux-2.6.20.i386.orig/net/ipv4/udp.c linux-2.6.20.i386/net/ipv4/udp.c
--- linux-2.6.20.i386.orig/net/ipv4/udp.c	2007-04-24 13:18:40.000000000 +1000
+++ linux-2.6.20.i386/net/ipv4/udp.c	2007-04-24 15:10:23.000000000 +1000
@@ -425,6 +425,7 @@
 		/*
 		 * Only one fragment on the socket.
 		 */
+		skb->csum_start = skb->h.raw - skb->head;
 		skb->csum_offset = offsetof(struct udphdr, check);
 		uh->check = csum_tcpudp_magic(src, dst, len, IPPROTO_UDP, 0);
 	} else {
diff -ur linux-2.6.20.i386.orig/net/ipv6/tcp_ipv6.c linux-2.6.20.i386/net/ipv6/tcp_ipv6.c
--- linux-2.6.20.i386.orig/net/ipv6/tcp_ipv6.c	2007-03-30 13:39:11.000000000 +1000
+++ linux-2.6.20.i386/net/ipv6/tcp_ipv6.c	2007-04-24 15:10:43.000000000 +1000
@@ -948,6 +948,7 @@
 
 	if (skb->ip_summed == CHECKSUM_PARTIAL) {
 		th->check = csum_ipv6_magic(&np->saddr, &np->daddr, len, IPPROTO_TCP,  0);
+		skb->csum_start = skb->h.raw - skb->head;
 		skb->csum_offset = offsetof(struct tcphdr, check);
 	} else {
 		th->check = csum_ipv6_magic(&np->saddr, &np->daddr, len, IPPROTO_TCP, 
@@ -970,6 +971,7 @@
 	th->check = 0;
 	th->check = csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,
 				     IPPROTO_TCP, 0);
+	skb->csum_start = skb->h.raw - skb->head;
 	skb->csum_offset = offsetof(struct tcphdr, check);
 	skb->ip_summed = CHECKSUM_PARTIAL;
 	return 0;


